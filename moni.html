<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>资金管理模拟器：全指标专业版</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        input[type=range] {
            -webkit-appearance: none; 
            background: transparent; 
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #4F46E5;
            cursor: pointer;
            margin-top: -8px; 
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
            border: 2px solid white;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 6px;
            cursor: pointer;
            background: #E2E8F0;
            border-radius: 4px;
        }
        .card { transition: transform 0.2s; }
        .chart-container { position: relative; height: 350px; width: 100%; }
        /* Custom styles */
        .text-gradient {
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
    </style>
</head>
<body class="bg-slate-50 text-slate-800 font-sans min-h-screen">

    <!-- Navbar -->
    <nav class="bg-white shadow-sm border-b border-slate-200">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex justify-between h-16 items-center">
                <div class="flex items-center gap-2">
                    <svg class="w-8 h-8 text-indigo-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path></svg>
                    <h1 class="text-xl font-bold text-slate-800">资金管理实验室</h1>
                </div>
                <div class="text-sm text-slate-500 hidden sm:block">Advanced Money Management Simulator</div>
            </div>
        </div>
    </nav>

    <main class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        
        <div class="grid grid-cols-1 lg:grid-cols-12 gap-6 mb-8">
            
            <!-- Controls Panel -->
            <div class="lg:col-span-4 bg-white rounded-xl shadow-sm border border-slate-200 p-6 card h-fit">
                <h2 class="text-lg font-semibold mb-6 flex items-center gap-2">
                    <svg class="w-5 h-5 text-slate-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6V4m0 2a2 2 0 100 4m0-4a2 2 0 110 4m-6 8a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4m6 6v10m6-2a2 2 0 100-4m0 4a2 2 0 110-4m0 4v2m0-6V4"></path></svg>
                    基础参数
                </h2>

                <!-- RR Slider -->
                <div class="mb-6">
                    <div class="flex justify-between mb-2">
                        <label class="text-sm font-bold text-slate-700">盈亏比 (R:R)</label>
                        <span class="text-indigo-600 font-bold" id="rrDisplay">1 : 2.0</span>
                    </div>
                    <!-- Modified min and step to allow 0.1 and 0.125 -->
                    <input type="range" min="0.1" max="5" step="0.025" value="2.0" class="w-full h-2 rounded-lg appearance-none cursor-pointer" id="rrSlider">
                </div>

                <!-- Win Rate Slider -->
                <div class="mb-6">
                    <div class="flex justify-between mb-2">
                        <label class="text-sm font-medium text-slate-600">胜率 (Win Rate)</label>
                        <span class="text-slate-700 font-bold" id="winRateDisplay">40%</span>
                    </div>
                    <input type="range" min="1" max="99" value="40" class="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer" id="winRateSlider">
                </div>

                 <!-- Trade Count Slider (New) -->
                 <div class="mb-6">
                    <div class="flex justify-between mb-2">
                        <label class="text-sm font-medium text-slate-600">交易笔数 (Trades)</label>
                        <span class="text-slate-700 font-bold" id="tradeCountDisplay">100</span>
                    </div>
                    <input type="range" min="50" max="2000" step="10" value="100" class="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer" id="tradeCountSlider">
                </div>

                <div class="border-t border-slate-100 my-6"></div>

                <h2 class="text-lg font-semibold mb-4 flex items-center gap-2 text-indigo-700">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 7h8m0 0v8m0-8l-8 8-4-4-6 6"></path></svg>
                    资金管理策略
                </h2>

                <!-- Money Management Selection -->
                <div class="mb-4">
                    <label class="block text-sm font-medium text-slate-600 mb-2">当前详情显示 / 参数调整</label>
                    <select id="mmStrategy" class="w-full bg-slate-50 border border-slate-300 text-slate-900 text-sm rounded-lg focus:ring-indigo-500 focus:border-indigo-500 block p-2.5">
                        <option value="fixed_pct">固定比例 (Fixed %) - 推荐</option>
                        <option value="fixed_amt">固定金额 (Fixed $)</option>
                        <option value="martingale">马丁格尔 (亏损加倍)</option>
                        <option value="anti_martingale">反马丁 (连胜加倍)</option>
                    </select>
                    <p class="text-xs text-slate-400 mt-1">提示：图表中始终同时显示 4 种策略以供对比。</p>
                </div>

                <!-- Base Risk -->
                <div class="mb-4">
                    <div class="flex justify-between mb-2">
                        <label class="text-sm font-medium text-slate-600">基础风险 (Base Risk)</label>
                        <span class="text-slate-700 font-bold" id="riskDisplay">1%</span>
                    </div>
                    <input type="range" min="0.1" max="5" step="0.1" value="1" class="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer" id="riskSlider">
                </div>

                <!-- Multiplier Controls (Hidden for Fixed strategies) -->
                <div id="multiplierControl" class="hidden mb-4 p-4 bg-indigo-50 rounded-lg border border-indigo-100 space-y-5">
                    
                    <!-- Multiplier Rate -->
                    <div>
                        <div class="flex justify-between mb-2">
                            <label class="text-sm font-bold text-indigo-800">加仓倍率 (Multiplier)</label>
                            <span class="text-indigo-600 font-bold" id="multDisplay">2.0x</span>
                        </div>
                        <input type="range" min="1.1" max="3.0" step="0.1" value="2.0" class="w-full h-2 bg-indigo-200 rounded-lg appearance-none cursor-pointer" id="multSlider">
                        <p class="text-xs text-indigo-600 mt-1" id="multDesc">亏损后下注金额 × 2.0</p>
                    </div>

                    <!-- Max Cap Limit -->
                    <div>
                        <div class="flex justify-between mb-2">
                            <label class="text-sm font-bold text-indigo-800">最大倍数限制 (Max Cap)</label>
                            <span class="text-indigo-600 font-bold" id="maxCapDisplay">8x</span>
                        </div>
                        <input type="range" min="1" max="64" step="1" value="8" class="w-full h-2 bg-indigo-200 rounded-lg appearance-none cursor-pointer" id="maxCapSlider">
                        <p class="text-xs text-indigo-600 mt-1">达到基础风险的 <span id="maxCapText">8</span> 倍后触发行为</p>
                    </div>

                    <!-- Cap Behavior (New) -->
                    <div>
                        <label class="text-sm font-bold text-indigo-800 mb-2 block">达到上限后行为</label>
                        <div class="flex gap-4">
                            <div class="flex items-center">
                                <input id="capCapped" type="radio" value="capped" name="capBehavior" class="w-4 h-4 text-indigo-600 bg-gray-100 border-gray-300 focus:ring-indigo-500 focus:ring-2" checked>
                                <label for="capCapped" class="ml-2 text-sm font-medium text-slate-700">硬抗 (保持上限)</label>
                            </div>
                            <div class="flex items-center">
                                <input id="capReset" type="radio" value="reset" name="capBehavior" class="w-4 h-4 text-indigo-600 bg-gray-100 border-gray-300 focus:ring-indigo-500 focus:ring-2">
                                <label for="capReset" class="ml-2 text-sm font-medium text-slate-700">重置 (回到1x)</label>
                            </div>
                        </div>
                         <p class="text-xs text-indigo-600 mt-1" id="capBehaviorDesc">马丁: 保持最大注码 | 反马丁: 保持最大注码</p>
                    </div>

                </div>

            </div>

            <!-- Analysis Panel -->
            <div class="lg:col-span-8 flex flex-col gap-6">
                
                <!-- Simulation Chart -->
                <div class="bg-white rounded-xl shadow-lg border border-slate-200 p-6 flex-grow flex flex-col min-h-[400px]">
                    <div class="flex justify-between items-center mb-4">
                        <div>
                            <h3 class="text-xl font-bold text-slate-800">全策略对比模拟</h3>
                            <p class="text-xs text-slate-500" id="simSubTitle">基础参数：胜率 40% | 盈亏比 1:2 | 初始资金 $10,000</p>
                        </div>
                        <div class="flex gap-2">
                             <button onclick="runSimulation()" class="bg-indigo-600 hover:bg-indigo-700 text-white text-sm font-medium py-2 px-4 rounded transition shadow-sm">
                                重新洗牌 (新随机序列)
                            </button>
                        </div>
                    </div>
                    
                    <div class="chart-container flex-grow relative">
                        <canvas id="simulationChart"></canvas>
                        <!-- Overlay for "BUSTED" -->
                        <div id="bustOverlay" class="hidden absolute inset-0 flex items-center justify-center bg-white/80 z-10 pointer-events-none">
                            <div class="text-center">
                                <div class="text-6xl font-black text-rose-600 mb-2">BUSTED</div>
                                <div class="text-xl text-rose-800">当前选中的策略已爆仓</div>
                            </div>
                        </div>
                    </div>

                    <!-- Stats Grid -->
                    <div class="mt-4 border-t border-slate-100 pt-4">
                        <div class="flex justify-between items-center mb-2">
                            <h4 class="text-sm font-bold text-slate-700">
                                当前选中详情：<span id="selectedStratName" class="text-indigo-600">固定比例</span>
                            </h4>
                        </div>
                        <div class="grid grid-cols-2 sm:grid-cols-4 gap-4">
                            <!-- Row 1 -->
                            <div class="text-center p-2 bg-slate-50 rounded-lg">
                                <div class="text-xs text-slate-400">最终余额</div>
                                <div class="font-bold text-slate-800" id="finalBalance">$--</div>
                            </div>
                            <div class="text-center p-2 bg-slate-50 rounded-lg">
                                <div class="text-xs text-slate-400">最大回撤 (DD%)</div>
                                <div class="font-bold text-rose-500" id="maxDrawdown">--%</div>
                            </div>
                            <div class="text-center p-2 bg-slate-50 rounded-lg">
                                <div class="text-xs text-slate-400">最大连亏</div>
                                <div class="font-bold text-slate-600" id="maxConsLoss">0</div>
                            </div>
                             <div class="text-center p-2 bg-slate-50 rounded-lg">
                                <div class="text-xs text-slate-400">最大单笔下注</div>
                                <div class="font-bold text-indigo-600" id="maxBetSize">$0</div>
                            </div>

                            <!-- Row 2: Advanced Metrics -->
                            <div class="text-center p-2 bg-indigo-50/50 rounded-lg border border-indigo-100">
                                <div class="text-xs text-slate-500">盈利因子 (PF)</div>
                                <div class="font-bold text-emerald-600" id="pfDisplay">--</div>
                            </div>
                            <div class="text-center p-2 bg-indigo-50/50 rounded-lg border border-indigo-100">
                                <div class="text-xs text-slate-500">夏普比率 (Sharpe)</div>
                                <div class="font-bold text-blue-600" id="sharpeDisplay">--</div>
                            </div>
                            <div class="text-center p-2 bg-indigo-50/50 rounded-lg border border-indigo-100">
                                <div class="text-xs text-slate-500">恢复系数 (Recover)</div>
                                <div class="font-bold text-purple-600" id="recoverDisplay">--</div>
                            </div>
                            <div class="text-center p-2 bg-indigo-50/50 rounded-lg border border-indigo-100">
                                <div class="text-xs text-slate-500">净利润 (Net)</div>
                                <div class="font-bold text-slate-700" id="netProfitDisplay">--</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Strategy Explanation -->
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div class="bg-white rounded-xl shadow-sm border border-slate-200 p-5">
                         <h4 class="font-bold text-slate-800 mb-2 border-b pb-2">当前策略特性</h4>
                         <div id="strategyExplanation" class="text-sm text-slate-600 leading-relaxed">
                             --
                         </div>
                    </div>
                    
                    <!-- Edge Analysis (Mini) -->
                    <div class="bg-slate-900 rounded-xl shadow-sm p-5 text-white">
                        <h4 class="font-bold text-slate-300 mb-2 border-b border-slate-700 pb-2">基础数学期望</h4>
                        <div class="flex justify-between items-center mb-2">
                            <span class="text-sm text-slate-400">期望值 (每1R风险)</span>
                            <span class="text-2xl font-bold" id="expectancyVal">--</span>
                        </div>
                        <div class="text-xs text-slate-500">
                            提示：对比红线（马丁）和绿线（复利）。马丁通常在归零前直线上升，但极其脆弱。复利则更稳健，随着本金增加曲线呈抛物线。
                        </div>
                    </div>
                </div>

            </div>
        </div>

    </main>

    <script>
        // --- State Management ---
        const state = {
            winRate: 0.40, 
            rrRatio: 2.0,  
            baseRiskPct: 0.01, // 1%
            startBalance: 10000,
            mmStrategy: 'fixed_pct', // This is now "Selected for Detail View"
            multiplier: 2.0,
            maxCap: 8,
            tradeCount: 100,
            capBehavior: 'capped' // 'capped' or 'reset'
        };

        // --- DOM Elements ---
        const els = {
            winRateSlider: document.getElementById('winRateSlider'),
            winRateDisplay: document.getElementById('winRateDisplay'),
            rrSlider: document.getElementById('rrSlider'),
            rrDisplay: document.getElementById('rrDisplay'),
            riskSlider: document.getElementById('riskSlider'),
            riskDisplay: document.getElementById('riskDisplay'),
            tradeCountSlider: document.getElementById('tradeCountSlider'),
            tradeCountDisplay: document.getElementById('tradeCountDisplay'),
            mmStrategy: document.getElementById('mmStrategy'),
            multSlider: document.getElementById('multSlider'),
            multDisplay: document.getElementById('multDisplay'),
            multDesc: document.getElementById('multDesc'),
            maxCapSlider: document.getElementById('maxCapSlider'),
            maxCapDisplay: document.getElementById('maxCapDisplay'),
            maxCapText: document.getElementById('maxCapText'),
            multiplierControl: document.getElementById('multiplierControl'),
            capBehaviorRadios: document.getElementsByName('capBehavior'),
            capBehaviorDesc: document.getElementById('capBehaviorDesc'),
            // Outputs
            finalBalance: document.getElementById('finalBalance'),
            maxDrawdown: document.getElementById('maxDrawdown'),
            maxConsLoss: document.getElementById('maxConsLoss'),
            maxBetSize: document.getElementById('maxBetSize'),
            // Advanced Outputs
            pfDisplay: document.getElementById('pfDisplay'),
            sharpeDisplay: document.getElementById('sharpeDisplay'),
            recoverDisplay: document.getElementById('recoverDisplay'),
            netProfitDisplay: document.getElementById('netProfitDisplay'),
            selectedStratName: document.getElementById('selectedStratName'),
            
            bustOverlay: document.getElementById('bustOverlay'),
            expectancyVal: document.getElementById('expectancyVal'),
            strategyExplanation: document.getElementById('strategyExplanation'),
            simSubTitle: document.getElementById('simSubTitle')
        };

        let simulationChartInstance = null;

        // --- Core Simulation Logic ---
        function runSimulation() {
            const tradeCount = state.tradeCount;
            // 1. Generate outcomes first (same for all strategies)
            const outcomes = []; // true = win, false = loss
            let winCount = 0;
            for(let i=0; i<tradeCount; i++) {
                const isWin = Math.random() < state.winRate;
                outcomes.push(isWin);
                if(isWin) winCount++;
            }
            
            // 2. Define Strategies
            const strategies = ['fixed_pct', 'fixed_amt', 'martingale', 'anti_martingale'];
            const allResults = {};

            strategies.forEach(strat => {
                allResults[strat] = simulateStrategy(strat, outcomes);
            });

            // 3. Update Chart
            renderChart(allResults);

            // 4. Update Stats for SELECTED strategy
            updateStatsUI(allResults[state.mmStrategy]);
            updateExpectancy();
        }

        function simulateStrategy(stratName, outcomes) {
            const dataPoints = [state.startBalance];
            const tradeResults = [];
            
            let currentBalance = state.startBalance;
            let peakBalance = state.startBalance;
            let maxDDPercentage = 0;
            let maxDDAmount = 0;
            let maxBet = 0;
            let consecutiveLosses = 0;
            let maxConsecutiveLosses = 0;
            let isBusted = false;
            let grossProfit = 0;
            let grossLoss = 0;

            let currentRiskAmount = 0;
            let lastTradeResult = null; // 'win' or 'loss'
            const baseRiskAmount = state.startBalance * state.baseRiskPct;

            for (let i = 0; i < outcomes.length; i++) {
                if (currentBalance <= 1 || isBusted) {
                    isBusted = true;
                    currentBalance = 0;
                    dataPoints.push(0);
                    tradeResults.push(0);
                    continue; 
                }

                // Determine Bet Size
                switch (stratName) {
                    case 'fixed_pct':
                        currentRiskAmount = currentBalance * state.baseRiskPct;
                        break;
                    case 'fixed_amt':
                        currentRiskAmount = baseRiskAmount;
                        break;
                    case 'martingale':
                        if (lastTradeResult === 'loss') {
                            let proposedRisk = currentRiskAmount * state.multiplier;
                            let maxRisk = baseRiskAmount * state.maxCap;
                            // Check behavior
                            if (proposedRisk > maxRisk) {
                                if (state.capBehavior === 'reset') {
                                    currentRiskAmount = baseRiskAmount;
                                } else {
                                    currentRiskAmount = maxRisk;
                                }
                            } else {
                                currentRiskAmount = proposedRisk;
                            }
                        } else {
                            currentRiskAmount = baseRiskAmount;
                        }
                        break;
                    case 'anti_martingale':
                        if (lastTradeResult === 'win') {
                            let proposedRisk = currentRiskAmount * state.multiplier;
                            let maxRisk = baseRiskAmount * state.maxCap;
                            // Check behavior
                            if (proposedRisk > maxRisk) {
                                if (state.capBehavior === 'reset') {
                                    currentRiskAmount = baseRiskAmount;
                                } else {
                                    currentRiskAmount = maxRisk;
                                }
                            } else {
                                currentRiskAmount = proposedRisk;
                            }
                        } else {
                            currentRiskAmount = baseRiskAmount;
                        }
                        break;
                }

                if (currentRiskAmount > currentBalance) currentRiskAmount = currentBalance;
                if (currentRiskAmount > maxBet) maxBet = currentRiskAmount;

                // Trade Outcome
                const isWin = outcomes[i];
                let tradePL = 0;

                if (isWin) {
                    tradePL = currentRiskAmount * state.rrRatio;
                    currentBalance += tradePL;
                    
                    grossProfit += tradePL;
                    lastTradeResult = 'win';
                    consecutiveLosses = 0;
                } else {
                    tradePL = -currentRiskAmount;
                    currentBalance -= currentRiskAmount;
                    
                    grossLoss += currentRiskAmount;
                    lastTradeResult = 'loss';
                    consecutiveLosses++;
                    if (consecutiveLosses > maxConsecutiveLosses) maxConsecutiveLosses = consecutiveLosses;
                }
                
                tradeResults.push(tradePL);

                // Drawdown
                if (currentBalance > peakBalance) peakBalance = currentBalance;
                
                const ddAmount = peakBalance - currentBalance;
                if (ddAmount > maxDDAmount) maxDDAmount = ddAmount;

                const ddPct = ddAmount / peakBalance;
                if (ddPct > maxDDPercentage) maxDDPercentage = ddPct;

                dataPoints.push(currentBalance);
            }

            // Calc Metrics
            let pf = grossLoss === 0 ? (grossProfit > 0 ? 999.0 : 0.0) : (grossProfit / grossLoss);
            
            let meanPL = tradeResults.length > 0 ? tradeResults.reduce((sum, val) => sum + val, 0) / tradeResults.length : 0;
            let variancePL = tradeResults.length > 0 ? tradeResults.reduce((sum, val) => sum + Math.pow(val - meanPL, 2), 0) / tradeResults.length : 0;
            let stdDevPL = Math.sqrt(variancePL);
            let sharpe = stdDevPL === 0 ? 0 : (meanPL / stdDevPL);

            let netProfit = currentBalance - state.startBalance;
            let recoveryFactor = maxDDAmount <= 1 ? (netProfit > 0 ? 99.0 : 0.0) : (netProfit / maxDDAmount);

            return {
                dataPoints,
                currentBalance,
                maxDDPercentage,
                maxConsecutiveLosses,
                maxBet,
                pf,
                sharpe,
                recoveryFactor,
                netProfit,
                isBusted
            };
        }

        function renderChart(allResults) {
            const ctx = document.getElementById('simulationChart').getContext('2d');
            
            if (simulationChartInstance) {
                simulationChartInstance.destroy();
            }

            // Labels 0 to tradeCount
            const labels = Array.from({length: state.tradeCount + 1}, (_, i) => i);

            // Dataset Configuration
            const datasets = [
                {
                    label: '固定比例 (Fixed %)',
                    data: allResults['fixed_pct'].dataPoints,
                    borderColor: '#10b981', // Emerald
                    backgroundColor: 'rgba(16, 185, 129, 0.1)',
                    borderWidth: 2,
                    pointRadius: 0,
                    tension: 0.1,
                    order: 1
                },
                {
                    label: '固定金额 (Fixed $)',
                    data: allResults['fixed_amt'].dataPoints,
                    borderColor: '#3b82f6', // Blue
                    backgroundColor: 'transparent',
                    borderWidth: 2,
                    pointRadius: 0,
                    tension: 0.1,
                    borderDash: [5, 5],
                    order: 2
                },
                {
                    label: '马丁格尔 (Martingale)',
                    data: allResults['martingale'].dataPoints,
                    borderColor: '#f43f5e', // Rose
                    backgroundColor: 'transparent',
                    borderWidth: 2,
                    pointRadius: 0,
                    tension: 0.1,
                    order: 3
                },
                {
                    label: '反马丁 (Anti-Mart)',
                    data: allResults['anti_martingale'].dataPoints,
                    borderColor: '#8b5cf6', // Violet
                    backgroundColor: 'transparent',
                    borderWidth: 2,
                    pointRadius: 0,
                    tension: 0.1,
                    order: 4
                }
            ];

            // Highlight selected strategy
            const selectedIdx = datasets.findIndex(d => 
                (state.mmStrategy === 'fixed_pct' && d.label.includes('固定比例')) ||
                (state.mmStrategy === 'fixed_amt' && d.label.includes('固定金额')) ||
                (state.mmStrategy === 'martingale' && d.label.includes('马丁')) ||
                (state.mmStrategy === 'anti_martingale' && d.label.includes('反马丁'))
            );
            
            if(selectedIdx !== -1) {
                datasets[selectedIdx].borderWidth = 4; // Thicker line for selected
                datasets[selectedIdx].order = 0; // Bring to front
            }

            simulationChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    interaction: { intersect: false, mode: 'index' },
                    scales: {
                        x: { display: true, title: {display:true, text:'交易次数'} },
                        y: { beginAtZero: true, title: {display:true, text:'资金'} }
                    },
                    plugins: { 
                        legend: { display: true, position: 'top' },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += '$' + Math.floor(context.parsed.y).toLocaleString();
                                    }
                                    return label;
                                }
                            }
                        }
                    }
                }
            });
        }

        function updateStatsUI(result) {
            // Check if busted
            if(result.isBusted) {
                els.bustOverlay.classList.remove('hidden');
            } else {
                els.bustOverlay.classList.add('hidden');
            }

            // Basic Stats
            els.finalBalance.textContent = '$' + Math.floor(result.currentBalance).toLocaleString();
            els.finalBalance.className = result.currentBalance > state.startBalance ? "font-bold text-emerald-600" : "font-bold text-rose-600";
            els.maxDrawdown.textContent = (result.maxDDPercentage * 100).toFixed(2) + '%';
            els.maxConsLoss.textContent = result.maxConsecutiveLosses;
            els.maxBetSize.textContent = '$' + Math.floor(result.maxBet).toLocaleString();

            // Advanced Stats
            els.pfDisplay.textContent = result.pf.toFixed(2);
            els.pfDisplay.className = result.pf > 1.5 ? "font-bold text-emerald-600" : (result.pf > 1 ? "font-bold text-blue-600" : "font-bold text-rose-600");
            
            els.sharpeDisplay.textContent = result.sharpe.toFixed(3);
            els.sharpeDisplay.className = result.sharpe > 0.1 ? "font-bold text-blue-600" : "font-bold text-slate-500";
            
            els.recoverDisplay.textContent = result.recoveryFactor.toFixed(2);
            els.recoverDisplay.className = result.recoveryFactor > 2 ? "font-bold text-purple-600" : (result.recoveryFactor > 0 ? "font-bold text-slate-600" : "font-bold text-rose-600");

            els.netProfitDisplay.textContent = (result.netProfit > 0 ? "+" : "") + '$' + Math.floor(result.netProfit).toLocaleString();
            els.netProfitDisplay.className = result.netProfit > 0 ? "font-bold text-emerald-700" : "font-bold text-rose-700";
        }

        function updateExpectancy() {
            const winRate = state.winRate;
            const reward = state.rrRatio;
            const risk = 1;
            const expectancy = (winRate * reward) - ((1 - winRate) * risk);
            
            const eVal = expectancy.toFixed(2) + ' R';
            const color = expectancy > 0 ? "text-emerald-400" : "text-rose-400";
            els.expectancyVal.innerHTML = `<span class="${color}">${eVal}</span>`;
        }

        function updateStrategyInfo() {
            const strat = state.mmStrategy;
            let text = "";
            let showMult = false;
            let labelName = "";
            let capDesc = state.capBehavior === 'reset' ? "重置" : "硬抗";

            if (strat === 'fixed_pct') {
                labelName = "固定比例 (Fixed %)";
                text = "<strong>复利增长模式 (绿色)：</strong> 推荐。资金管理圣杯。利用复利效应，在连胜时加速，连败时自动减小头寸保护本金。通常产生较高的夏普比率。";
            } else if (strat === 'fixed_amt') {
                labelName = "固定金额 (Fixed $)";
                text = "<strong>单利模式 (蓝色虚线)：</strong> 线性增长。风险固定。随着账户增长，实际上是在降低风险比例（De-leveraging）。";
            } else if (strat === 'martingale') {
                showMult = true;
                labelName = "马丁格尔 (Martingale)";
                text = `<strong>马丁格尔 (红色)：</strong> 输了加倍。达到 ${state.maxCap} 倍上限后：<strong>${capDesc}</strong>。<br>硬抗：维持最大注码直到获胜。重置：认输，回到 1x 止损。`;
                els.multDesc.textContent = `亏损后下注金额 × ${state.multiplier.toFixed(1)}`;
                els.capBehaviorDesc.textContent = `马丁: 连亏到上限后${state.capBehavior === 'reset' ? '重置(认亏)' : '硬抗(继续大注)'}`;
            } else if (strat === 'anti_martingale') {
                showMult = true;
                labelName = "反马丁 (Anti-Mart)";
                text = `<strong>反马丁 (紫色)：</strong> 赢了加倍。达到 ${state.maxCap} 倍上限后：<strong>${capDesc}</strong>。<br>硬抗：Ride the streak，继续用最大注码博弈。重置：Paroli，锁定利润，落袋为安。`;
                els.multDesc.textContent = `盈利后下注金额 × ${state.multiplier.toFixed(1)}`;
                els.capBehaviorDesc.textContent = `反马丁: 连胜到上限后${state.capBehavior === 'reset' ? '重置(落袋为安)' : '硬抗(乘胜追击)'}`;
            }

            els.selectedStratName.textContent = labelName;
            els.strategyExplanation.innerHTML = text;
            
            if (showMult) {
                els.multiplierControl.classList.remove('hidden');
            } else {
                els.multiplierControl.classList.add('hidden');
            }
        }

        // --- Event Listeners ---
        function handleInput() {
            // Update State
            state.winRate = parseInt(els.winRateSlider.value) / 100;
            state.rrRatio = parseFloat(els.rrSlider.value);
            state.baseRiskPct = parseFloat(els.riskSlider.value) / 100;
            state.mmStrategy = els.mmStrategy.value;
            state.multiplier = parseFloat(els.multSlider.value);
            state.maxCap = parseInt(els.maxCapSlider.value);
            state.tradeCount = parseInt(els.tradeCountSlider.value);
            
            // Get selected radio
            for(const radio of els.capBehaviorRadios) {
                if(radio.checked) {
                    state.capBehavior = radio.value;
                    break;
                }
            }

            // Update UI Labels
            els.winRateDisplay.textContent = Math.round(state.winRate * 100) + '%';
            
            // Format RR string
            let rrVal = state.rrRatio;
            let rrStr = (rrVal % 1 === 0) ? rrVal.toFixed(1) : rrVal.toString();
            els.rrDisplay.textContent = '1 : ' + rrStr;
            
            els.riskDisplay.textContent = (state.baseRiskPct * 100).toFixed(1) + '%';
            els.multDisplay.textContent = state.multiplier.toFixed(1) + 'x';
            els.maxCapDisplay.textContent = state.maxCap + 'x';
            els.maxCapText.textContent = state.maxCap;
            els.tradeCountDisplay.textContent = state.tradeCount;
            
            els.simSubTitle.textContent = `基础参数：胜率 ${(state.winRate*100).toFixed(0)}% | 盈亏比 1:${rrStr} | 初始资金 $10,000 | 交易 ${state.tradeCount} 笔`;

            updateStrategyInfo();
            runSimulation();
        }

        [els.winRateSlider, els.rrSlider, els.riskSlider, els.mmStrategy, els.multSlider, els.maxCapSlider, els.tradeCountSlider].forEach(el => {
            el.addEventListener('input', handleInput);
        });
        
        // Add listeners for radio buttons
        for(const radio of els.capBehaviorRadios) {
            radio.addEventListener('change', handleInput);
        }

        // --- Init ---
        window.addEventListener('DOMContentLoaded', () => {
            handleInput(); // Initial setup
        });

    </script>
</body>
</html>
